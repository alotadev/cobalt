// Copyright 2017 The Fuchsia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

package cobalt;

option go_package = "cobalt";

import "observation.proto";

/////////////////////////////////////////////////////////////////////////////
// A Report is the final output of the Cobalt Analyzer.
//
// A report is specified by a ReportConfig (see config/report_configs.proto).
// An instance of a report, in addition to which ReportConfig it is for,
// is uniquely identified by the timestamp at which the report was run
// and random identifier.
/////////////////////////////////////////////////////////////////////////////

// Which slice of the variables does a given report describe?
//
// A ReportConfig may specify one or two variables to analyze. Each instance
// of a report will describe either one of the variables or both variables
// jointly.
enum VariableSlice {
  // The report analyzed only variable 1. This is the default.
  VARIABLE_1 = 0;

  // The report analyzed only variable 2
  VARIABLE_2 = 1;

  // The report analyzed variable 1 and variable 2 jointly.
  JOINT = 2;
}

// The unique identifier for an instance of a report
message ReportId {
  // (customer_id, project_id, report_config_id) together specify which
  // ReportConfig this is a report for.
  uint32 customer_id = 1;
  uint32 project_id= 2;
  uint32 report_config_id= 3;

  // A report is an instance of the class of all reports that share a
  // ReportConfig. The instance_id uniquely represents this report instance.
  // It is randomly generated.
  uint32 instance_id = 4;

  // The time, in milliseconds since the Unix epoch, that the report processing
  // began, as recorded by the server. In the case that there are multiple
  // associated sub-reports that share this ReportId (except for the
  // |variable_slice| field), this field contains the timestamp of the time
  // when the first of the associated sub-reports was started. See the
  // field with the same name in ReportMetadata for when each sub-report
  // was started. (This value is part of the ReportId so that we don't need
  // an additional index on this value.)
  uint64 start_timestamp_ms= 5;

  // Including this enum as part of the ReportID alows us to support the notion
  // of multiple related sub-reports. Two ReportIds that are identical except
  // for the value of |variable_slice| are considered to be the IDs of
  // related sub-reports.
  VariableSlice variable_slice = 6;
}

// Metadata about an instance of a report.
message ReportMetadata {
  enum Status {
    // The report is still in progress.
    IN_PROGRESS = 0;

    // The report has completed successfully.
    COMPLETED_SUCCESSFULLY = 1;

    // The report terminated without completing successfully. More information
    // may be found in the |info_message|.
    TERMINATED = 2;
  }

  // The current status of the report.
  Status status = 1;

  // The time, in milliseconds since the Unix epoch, the report processing
  // of this sub-report began, as recorded by the server. The reason that this
  // field appears here in addition to a similar field appearing in ReportId
  // is in order to support the notion of associated sub-reports. Two different
  // related sub-reports have the same ReportId prefix--they differ only in
  // the values of their |variable_slice| field. Thus the |start_timestamp_ms|
  // field in ReportId cannot be used to record the start time of multiple
  // associated sub-reports that are run sequentially. This field contains the
  // timestamp of when the sub-report was started.
  uint64 start_timestamp_ms = 2;

  // The time, in milliseconds since the Unix epoch, that the report processing
  // finished, as recorded by the server.
  uint64 finish_timestamp_ms = 3;

  // The report analyzed Observations with a day_index in the range
  // [first_day_index, last_day_index]
  uint32 first_day_index = 4;
  uint32 last_day_index = 5;

  // Was this report instance explicitly requested as opposed to being generated
  // by the regular report scheduling? This only serves the purpose of helping
  // a consumer of the report understand  what caused the report to be
  // generated.
  bool requested = 6;

  // Any human-readable messages about this report generated by the server.
  string info_message = 7;
}

// A single row of a report.
message ReportRow {
  // The values for this row. A report analyzes either 1 or two variables.
  // If this is a univariate report then only |value| will be present.
  ValuePart value = 1;
  ValuePart value2 = 2;

  // This field is the primary output of Cobalt Analysis. It is an estimate
  // of the true count of the value or values in the user population.
  float count_estimate = 3;

  // Multiply this value by z_{alpha/2} to obtain the radius of an approximate
  // 100(1 - alpha)% confidence interval. For example an approximate 95%
  // confidence interval for the count is given by
  // (count_estimate - 1.96*std_error, count_estimate + 1.96 * std_error)
  // because 1.96 ~= z_{.025} meaning that P(Z > 1.96) ~= 0.025 where
  // Z ~ Normal(0, 1).
  float std_error = 4;
}

message Report {
  ReportMetadata metadata = 1;

  // The rows of the report.
  repeated ReportRow rows = 2;
}

